 CS50 is without doubt the world’s most elite computing course. It’s taught not only at Harvard, but now at fellow Ivy League institution Yale, where it instantly became the university’s most popular course in its first year. If you’re one of the many who fail to get a place on the course at one of the universities, you can take CS50 online, either via digital institutions such as edX or iTunes U, or simply via the course’s website, where all the lectures, tutorials, materials, assignments and their solutions are published for free. Lectures will soon even be watchable using VR headsets, as if you’re actually sat in the halls at Harvard. 
 In the beginning you might encourage them and give them simpler programming tasks. However even then you find too many of your other resources are being used to help these individuals. They have other skills; it’s just programming hasn’t come naturally to them and they don’t really enjoy it. If you don’t enjoy programming and you don’t have that inherit need to problem solve or get an answer to solution, it is unlikely you will have the urge to program and develop your skills. The best way to pick up programming skills is from trial & error and that comes from needing to solve the problem.
Unless of course I have a goal to achieve and I need to use programming to get there.
  Let me explain myself, I studied computing at university and I currently work as a software developer. I have been programming for a few years now. I see it as a way to create something. I enjoy being creative. I like being able to take a concept and move it to a point where it is substantial and others find pleasure in using it. However, I do not particularly like programming itself. I don’t freak out about design patterns. I never think about how I can optimize the codebase to shave 2–3 seconds off of the processing speed. I don’t get particularly excited about trying out new libraries, framework or languages.
* My habits have been evolved in computer science and get more oriented by this course:
* build one part at a time
* solve some examples by hand
* plan your code before you start writing it
* write the code
* test the examples that you have solved by hand
* test additional examples including “borderline” and random cases
This magic formula won't solve everything automatically, but it can save you headaches and reduce the number of problems you deal with later on. Students will analyze algorithms to compare correctness, run times, efficiencies and inefficiencies. Students will also explore computational problems and explain the difference between solvable and unsolvable problems. At the end, I tell myself and my mates that, you must understand that it is normal to feel lost. There is nothing wrong with you, and there is nothing wrong with the course—feeling lost is a consequence of the situation: where you’re coming from and where you’re going to…more and more user cases everything will be perfect.
